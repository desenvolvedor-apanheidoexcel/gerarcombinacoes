/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import org.knowm.xchart.SwingWrapper
import org.knowm.xchart.XYChartBuilder
import org.knowm.xchart.XYChart

class App {
    val greeting: String
        get() {
            return "Gerador de Combinacoes - Pac Man... memory!"
        }
}

fun main(args: Array<String>) {
    println("Iniciando monitoramento de memoria...")

    val tempos = mutableListOf<Double>()
    val consumos = mutableListOf<Long>()

    val obrigatorios = parseObrigatoriosFromArgs(args)
    val (start, qtd) = parseIntervalFromArgs(args)

    // Monitorar por 10 segundos (20 medições de 0,5s)
    for (i in 0..20) {
        tempos.add(i * 0.5) // tempo em segundos
        consumos.add(memoriaUsada())

        // Simulação de trabalho: na metade do tempo gera combinações
        if (i == 10) {
            println("Gerando combinacoes...")
            val jogos = gerarCombinacoesComObrigatorios(obrigatorios)
            if (start != null && qtd != null && start >= 1 && qtd > 0) {
                val fromIdx = (start - 1).coerceAtLeast(0)
                val toIdx = (fromIdx + qtd).coerceAtMost(jogos.size)
                val slice = if (fromIdx < toIdx) jogos.subList(fromIdx, toIdx) else emptyList()
                var pos = start
                for (jogo in slice) {
                    println("Jogo #$pos: ${jogo.sorted()} ")
                    pos++
                }
                println("Impressos ${slice.size} jogos do intervalo [$start..${start + qtd - 1}].")
            } else {
                println("Gerados ${jogos.size} jogos que contem os numeros $obrigatorios.")
            }
        }

        Thread.sleep(500) // espera 0,5 segundos
    }

    // Sempre imprimir o total de combinações geradas ao final
    val n = 25 - obrigatorios.size
    val k = 15 - obrigatorios.size
    val totalFinal = binomial(n, k)
    println("Total de jogos gerados: $totalFinal.")

    // Plotar gráfico
    plotarGrafico(tempos, consumos)
}

fun memoriaUsada(): Long {
    val runtime = Runtime.getRuntime()
    val usedBytes = runtime.totalMemory() - runtime.freeMemory()
    return usedBytes / (1024 * 1024) // MB
}

fun gerarCombinacoesComObrigatorios(obrigatorios: Set<Int>): List<Set<Int>> {
    require(obrigatorios.all { it in 1..25 }) { "Numeros fora do intervalo" }
    require(obrigatorios.size <= 15) { "Maximo de 15 numeros" }

    val restante = (1..25).toSet() - obrigatorios
    val faltam = 15 - obrigatorios.size

    val combinacoes = combinacoes(restante.toList(), faltam)
    return combinacoes.map { obrigatorios + it.toSet() }
}

fun <T> combinacoes(lista: List<T>, k: Int): List<List<T>> {
    if (k == 0) return listOf(emptyList())
    if (lista.isEmpty()) return emptyList()

    val cabeca = lista.first()
    val cauda = lista.drop(1)

    val comCabeca = combinacoes(cauda, k - 1).map { listOf(cabeca) + it }
    val semCabeca = combinacoes(cauda, k)

    return comCabeca + semCabeca
}

fun plotarGrafico(tempos: List<Double>, consumos: List<Long>) {
    val chart: XYChart = XYChartBuilder()
        .width(800).height(600)
        .title("Consumo de Memoria ao longo do tempo")
        .xAxisTitle("Tempo (s)")
        .yAxisTitle("Memoria (MB)")
        .build()

    chart.addSeries("Uso de Memoria", tempos, consumos)

    SwingWrapper(chart).displayChart()
}

// Usa `binomial` definido em AppSequence.kt




